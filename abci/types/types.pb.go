// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rollkit/abci/types.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/tendermint/tendermint/abci/types"
	crypto "github.com/tendermint/tendermint/proto/tendermint/crypto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Operation int32

const (
	Operation_write  Operation = 0
	Operation_read   Operation = 1
	Operation_delete Operation = 2
)

var Operation_name = map[int32]string{
	0: "WRITE",
	1: "READ",
	2: "DELETE",
}

var Operation_value = map[string]int32{
	"WRITE":  0,
	"READ":   1,
	"DELETE": 2,
}

func (x Operation) String() string {
	return proto.EnumName(Operation_name, int32(x))
}

func (Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{0}
}

type Request struct {
	// Types that are valid to be assigned to Value:
	//	*Request_Echo
	//	*Request_Flush
	//	*Request_Info
	//	*Request_SetOption
	//	*Request_InitChain
	//	*Request_Query
	//	*Request_BeginBlock
	//	*Request_CheckTx
	//	*Request_DeliverTx
	//	*Request_EndBlock
	//	*Request_Commit
	//	*Request_ListSnapshots
	//	*Request_OfferSnapshot
	//	*Request_LoadSnapshotChunk
	//	*Request_ApplySnapshotChunk
	//	*Request_GetAppHash
	//	*Request_GenerateFraudProof
	//	*Request_VerifyFraudProof
	Value isRequest_Value `protobuf_oneof:"value"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

type isRequest_Value interface {
	isRequest_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Request_Echo struct {
	Echo *types.RequestEcho `protobuf:"bytes,1,opt,name=echo,proto3,oneof" json:"echo,omitempty"`
}
type Request_Flush struct {
	Flush *types.RequestFlush `protobuf:"bytes,2,opt,name=flush,proto3,oneof" json:"flush,omitempty"`
}
type Request_Info struct {
	Info *types.RequestInfo `protobuf:"bytes,3,opt,name=info,proto3,oneof" json:"info,omitempty"`
}
type Request_SetOption struct {
	SetOption *types.RequestSetOption `protobuf:"bytes,4,opt,name=set_option,json=setOption,proto3,oneof" json:"set_option,omitempty"`
}
type Request_InitChain struct {
	InitChain *types.RequestInitChain `protobuf:"bytes,5,opt,name=init_chain,json=initChain,proto3,oneof" json:"init_chain,omitempty"`
}
type Request_Query struct {
	Query *types.RequestQuery `protobuf:"bytes,6,opt,name=query,proto3,oneof" json:"query,omitempty"`
}
type Request_BeginBlock struct {
	BeginBlock *types.RequestBeginBlock `protobuf:"bytes,7,opt,name=begin_block,json=beginBlock,proto3,oneof" json:"begin_block,omitempty"`
}
type Request_CheckTx struct {
	CheckTx *types.RequestCheckTx `protobuf:"bytes,8,opt,name=check_tx,json=checkTx,proto3,oneof" json:"check_tx,omitempty"`
}
type Request_DeliverTx struct {
	DeliverTx *types.RequestDeliverTx `protobuf:"bytes,9,opt,name=deliver_tx,json=deliverTx,proto3,oneof" json:"deliver_tx,omitempty"`
}
type Request_EndBlock struct {
	EndBlock *types.RequestEndBlock `protobuf:"bytes,10,opt,name=end_block,json=endBlock,proto3,oneof" json:"end_block,omitempty"`
}
type Request_Commit struct {
	Commit *types.RequestCommit `protobuf:"bytes,11,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}
type Request_ListSnapshots struct {
	ListSnapshots *types.RequestListSnapshots `protobuf:"bytes,12,opt,name=list_snapshots,json=listSnapshots,proto3,oneof" json:"list_snapshots,omitempty"`
}
type Request_OfferSnapshot struct {
	OfferSnapshot *types.RequestOfferSnapshot `protobuf:"bytes,13,opt,name=offer_snapshot,json=offerSnapshot,proto3,oneof" json:"offer_snapshot,omitempty"`
}
type Request_LoadSnapshotChunk struct {
	LoadSnapshotChunk *types.RequestLoadSnapshotChunk `protobuf:"bytes,14,opt,name=load_snapshot_chunk,json=loadSnapshotChunk,proto3,oneof" json:"load_snapshot_chunk,omitempty"`
}
type Request_ApplySnapshotChunk struct {
	ApplySnapshotChunk *types.RequestApplySnapshotChunk `protobuf:"bytes,15,opt,name=apply_snapshot_chunk,json=applySnapshotChunk,proto3,oneof" json:"apply_snapshot_chunk,omitempty"`
}
type Request_GetAppHash struct {
	GetAppHash *RequestGetAppHash `protobuf:"bytes,16,opt,name=get_app_hash,json=getAppHash,proto3,oneof" json:"get_app_hash,omitempty"`
}
type Request_GenerateFraudProof struct {
	GenerateFraudProof *RequestGenerateFraudProof `protobuf:"bytes,17,opt,name=generate_fraud_proof,json=generateFraudProof,proto3,oneof" json:"generate_fraud_proof,omitempty"`
}
type Request_VerifyFraudProof struct {
	VerifyFraudProof *RequestVerifyFraudProof `protobuf:"bytes,18,opt,name=verify_fraud_proof,json=verifyFraudProof,proto3,oneof" json:"verify_fraud_proof,omitempty"`
}

func (*Request_Echo) isRequest_Value()               {}
func (*Request_Flush) isRequest_Value()              {}
func (*Request_Info) isRequest_Value()               {}
func (*Request_SetOption) isRequest_Value()          {}
func (*Request_InitChain) isRequest_Value()          {}
func (*Request_Query) isRequest_Value()              {}
func (*Request_BeginBlock) isRequest_Value()         {}
func (*Request_CheckTx) isRequest_Value()            {}
func (*Request_DeliverTx) isRequest_Value()          {}
func (*Request_EndBlock) isRequest_Value()           {}
func (*Request_Commit) isRequest_Value()             {}
func (*Request_ListSnapshots) isRequest_Value()      {}
func (*Request_OfferSnapshot) isRequest_Value()      {}
func (*Request_LoadSnapshotChunk) isRequest_Value()  {}
func (*Request_ApplySnapshotChunk) isRequest_Value() {}
func (*Request_GetAppHash) isRequest_Value()         {}
func (*Request_GenerateFraudProof) isRequest_Value() {}
func (*Request_VerifyFraudProof) isRequest_Value()   {}

func (m *Request) GetValue() isRequest_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Request) GetEcho() *types.RequestEcho {
	if x, ok := m.GetValue().(*Request_Echo); ok {
		return x.Echo
	}
	return nil
}

func (m *Request) GetFlush() *types.RequestFlush {
	if x, ok := m.GetValue().(*Request_Flush); ok {
		return x.Flush
	}
	return nil
}

func (m *Request) GetInfo() *types.RequestInfo {
	if x, ok := m.GetValue().(*Request_Info); ok {
		return x.Info
	}
	return nil
}

func (m *Request) GetSetOption() *types.RequestSetOption {
	if x, ok := m.GetValue().(*Request_SetOption); ok {
		return x.SetOption
	}
	return nil
}

func (m *Request) GetInitChain() *types.RequestInitChain {
	if x, ok := m.GetValue().(*Request_InitChain); ok {
		return x.InitChain
	}
	return nil
}

func (m *Request) GetQuery() *types.RequestQuery {
	if x, ok := m.GetValue().(*Request_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Request) GetBeginBlock() *types.RequestBeginBlock {
	if x, ok := m.GetValue().(*Request_BeginBlock); ok {
		return x.BeginBlock
	}
	return nil
}

func (m *Request) GetCheckTx() *types.RequestCheckTx {
	if x, ok := m.GetValue().(*Request_CheckTx); ok {
		return x.CheckTx
	}
	return nil
}

func (m *Request) GetDeliverTx() *types.RequestDeliverTx {
	if x, ok := m.GetValue().(*Request_DeliverTx); ok {
		return x.DeliverTx
	}
	return nil
}

func (m *Request) GetEndBlock() *types.RequestEndBlock {
	if x, ok := m.GetValue().(*Request_EndBlock); ok {
		return x.EndBlock
	}
	return nil
}

func (m *Request) GetCommit() *types.RequestCommit {
	if x, ok := m.GetValue().(*Request_Commit); ok {
		return x.Commit
	}
	return nil
}

func (m *Request) GetListSnapshots() *types.RequestListSnapshots {
	if x, ok := m.GetValue().(*Request_ListSnapshots); ok {
		return x.ListSnapshots
	}
	return nil
}

func (m *Request) GetOfferSnapshot() *types.RequestOfferSnapshot {
	if x, ok := m.GetValue().(*Request_OfferSnapshot); ok {
		return x.OfferSnapshot
	}
	return nil
}

func (m *Request) GetLoadSnapshotChunk() *types.RequestLoadSnapshotChunk {
	if x, ok := m.GetValue().(*Request_LoadSnapshotChunk); ok {
		return x.LoadSnapshotChunk
	}
	return nil
}

func (m *Request) GetApplySnapshotChunk() *types.RequestApplySnapshotChunk {
	if x, ok := m.GetValue().(*Request_ApplySnapshotChunk); ok {
		return x.ApplySnapshotChunk
	}
	return nil
}

func (m *Request) GetGetAppHash() *RequestGetAppHash {
	if x, ok := m.GetValue().(*Request_GetAppHash); ok {
		return x.GetAppHash
	}
	return nil
}

func (m *Request) GetGenerateFraudProof() *RequestGenerateFraudProof {
	if x, ok := m.GetValue().(*Request_GenerateFraudProof); ok {
		return x.GenerateFraudProof
	}
	return nil
}

func (m *Request) GetVerifyFraudProof() *RequestVerifyFraudProof {
	if x, ok := m.GetValue().(*Request_VerifyFraudProof); ok {
		return x.VerifyFraudProof
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Request) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Request_Echo)(nil),
		(*Request_Flush)(nil),
		(*Request_Info)(nil),
		(*Request_SetOption)(nil),
		(*Request_InitChain)(nil),
		(*Request_Query)(nil),
		(*Request_BeginBlock)(nil),
		(*Request_CheckTx)(nil),
		(*Request_DeliverTx)(nil),
		(*Request_EndBlock)(nil),
		(*Request_Commit)(nil),
		(*Request_ListSnapshots)(nil),
		(*Request_OfferSnapshot)(nil),
		(*Request_LoadSnapshotChunk)(nil),
		(*Request_ApplySnapshotChunk)(nil),
		(*Request_GetAppHash)(nil),
		(*Request_GenerateFraudProof)(nil),
		(*Request_VerifyFraudProof)(nil),
	}
}

// Gets the current appHash
type RequestGetAppHash struct {
}

func (m *RequestGetAppHash) Reset()         { *m = RequestGetAppHash{} }
func (m *RequestGetAppHash) String() string { return proto.CompactTextString(m) }
func (*RequestGetAppHash) ProtoMessage()    {}
func (*RequestGetAppHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{1}
}
func (m *RequestGetAppHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGetAppHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGetAppHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGetAppHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGetAppHash.Merge(m, src)
}
func (m *RequestGetAppHash) XXX_Size() int {
	return m.Size()
}
func (m *RequestGetAppHash) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGetAppHash.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGetAppHash proto.InternalMessageInfo

// Generates a fraud proof
type RequestGenerateFraudProof struct {
	BeginBlockRequest types.RequestBeginBlock   `protobuf:"bytes,1,opt,name=begin_block_request,json=beginBlockRequest,proto3" json:"begin_block_request"`
	DeliverTxRequests []*types.RequestDeliverTx `protobuf:"bytes,2,rep,name=deliver_tx_requests,json=deliverTxRequests,proto3" json:"deliver_tx_requests,omitempty"`
	EndBlockRequest   *types.RequestEndBlock    `protobuf:"bytes,3,opt,name=end_block_request,json=endBlockRequest,proto3" json:"end_block_request,omitempty"`
}

func (m *RequestGenerateFraudProof) Reset()         { *m = RequestGenerateFraudProof{} }
func (m *RequestGenerateFraudProof) String() string { return proto.CompactTextString(m) }
func (*RequestGenerateFraudProof) ProtoMessage()    {}
func (*RequestGenerateFraudProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{2}
}
func (m *RequestGenerateFraudProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGenerateFraudProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGenerateFraudProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGenerateFraudProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGenerateFraudProof.Merge(m, src)
}
func (m *RequestGenerateFraudProof) XXX_Size() int {
	return m.Size()
}
func (m *RequestGenerateFraudProof) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGenerateFraudProof.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGenerateFraudProof proto.InternalMessageInfo

func (m *RequestGenerateFraudProof) GetBeginBlockRequest() types.RequestBeginBlock {
	if m != nil {
		return m.BeginBlockRequest
	}
	return types.RequestBeginBlock{}
}

func (m *RequestGenerateFraudProof) GetDeliverTxRequests() []*types.RequestDeliverTx {
	if m != nil {
		return m.DeliverTxRequests
	}
	return nil
}

func (m *RequestGenerateFraudProof) GetEndBlockRequest() *types.RequestEndBlock {
	if m != nil {
		return m.EndBlockRequest
	}
	return nil
}

// Verifies a fraud proof
type RequestVerifyFraudProof struct {
	FraudProof           *FraudProof `protobuf:"bytes,1,opt,name=fraud_proof,json=fraudProof,proto3" json:"fraud_proof,omitempty"`
	ExpectedValidAppHash []byte      `protobuf:"bytes,2,opt,name=expected_valid_app_hash,json=expectedValidAppHash,proto3" json:"expected_valid_app_hash,omitempty"`
}

func (m *RequestVerifyFraudProof) Reset()         { *m = RequestVerifyFraudProof{} }
func (m *RequestVerifyFraudProof) String() string { return proto.CompactTextString(m) }
func (*RequestVerifyFraudProof) ProtoMessage()    {}
func (*RequestVerifyFraudProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{3}
}
func (m *RequestVerifyFraudProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVerifyFraudProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVerifyFraudProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestVerifyFraudProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVerifyFraudProof.Merge(m, src)
}
func (m *RequestVerifyFraudProof) XXX_Size() int {
	return m.Size()
}
func (m *RequestVerifyFraudProof) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVerifyFraudProof.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVerifyFraudProof proto.InternalMessageInfo

func (m *RequestVerifyFraudProof) GetFraudProof() *FraudProof {
	if m != nil {
		return m.FraudProof
	}
	return nil
}

func (m *RequestVerifyFraudProof) GetExpectedValidAppHash() []byte {
	if m != nil {
		return m.ExpectedValidAppHash
	}
	return nil
}

type Response struct {
	// Types that are valid to be assigned to Value:
	//	*Response_Exception
	//	*Response_Echo
	//	*Response_Flush
	//	*Response_Info
	//	*Response_SetOption
	//	*Response_InitChain
	//	*Response_Query
	//	*Response_BeginBlock
	//	*Response_CheckTx
	//	*Response_DeliverTx
	//	*Response_EndBlock
	//	*Response_Commit
	//	*Response_ListSnapshots
	//	*Response_OfferSnapshot
	//	*Response_LoadSnapshotChunk
	//	*Response_ApplySnapshotChunk
	//	*Response_GetAppHash
	//	*Response_GenerateFraudProof
	//	*Response_VerifyFraudProof
	Value isResponse_Value `protobuf_oneof:"value"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{4}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

type isResponse_Value interface {
	isResponse_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Response_Exception struct {
	Exception *types.ResponseException `protobuf:"bytes,1,opt,name=exception,proto3,oneof" json:"exception,omitempty"`
}
type Response_Echo struct {
	Echo *types.ResponseEcho `protobuf:"bytes,2,opt,name=echo,proto3,oneof" json:"echo,omitempty"`
}
type Response_Flush struct {
	Flush *types.ResponseFlush `protobuf:"bytes,3,opt,name=flush,proto3,oneof" json:"flush,omitempty"`
}
type Response_Info struct {
	Info *types.ResponseInfo `protobuf:"bytes,4,opt,name=info,proto3,oneof" json:"info,omitempty"`
}
type Response_SetOption struct {
	SetOption *types.ResponseSetOption `protobuf:"bytes,5,opt,name=set_option,json=setOption,proto3,oneof" json:"set_option,omitempty"`
}
type Response_InitChain struct {
	InitChain *types.ResponseInitChain `protobuf:"bytes,6,opt,name=init_chain,json=initChain,proto3,oneof" json:"init_chain,omitempty"`
}
type Response_Query struct {
	Query *types.ResponseQuery `protobuf:"bytes,7,opt,name=query,proto3,oneof" json:"query,omitempty"`
}
type Response_BeginBlock struct {
	BeginBlock *types.ResponseBeginBlock `protobuf:"bytes,8,opt,name=begin_block,json=beginBlock,proto3,oneof" json:"begin_block,omitempty"`
}
type Response_CheckTx struct {
	CheckTx *types.ResponseCheckTx `protobuf:"bytes,9,opt,name=check_tx,json=checkTx,proto3,oneof" json:"check_tx,omitempty"`
}
type Response_DeliverTx struct {
	DeliverTx *types.ResponseDeliverTx `protobuf:"bytes,10,opt,name=deliver_tx,json=deliverTx,proto3,oneof" json:"deliver_tx,omitempty"`
}
type Response_EndBlock struct {
	EndBlock *types.ResponseEndBlock `protobuf:"bytes,11,opt,name=end_block,json=endBlock,proto3,oneof" json:"end_block,omitempty"`
}
type Response_Commit struct {
	Commit *types.ResponseCommit `protobuf:"bytes,12,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}
type Response_ListSnapshots struct {
	ListSnapshots *types.ResponseListSnapshots `protobuf:"bytes,13,opt,name=list_snapshots,json=listSnapshots,proto3,oneof" json:"list_snapshots,omitempty"`
}
type Response_OfferSnapshot struct {
	OfferSnapshot *types.ResponseOfferSnapshot `protobuf:"bytes,14,opt,name=offer_snapshot,json=offerSnapshot,proto3,oneof" json:"offer_snapshot,omitempty"`
}
type Response_LoadSnapshotChunk struct {
	LoadSnapshotChunk *types.ResponseLoadSnapshotChunk `protobuf:"bytes,15,opt,name=load_snapshot_chunk,json=loadSnapshotChunk,proto3,oneof" json:"load_snapshot_chunk,omitempty"`
}
type Response_ApplySnapshotChunk struct {
	ApplySnapshotChunk *types.ResponseApplySnapshotChunk `protobuf:"bytes,16,opt,name=apply_snapshot_chunk,json=applySnapshotChunk,proto3,oneof" json:"apply_snapshot_chunk,omitempty"`
}
type Response_GetAppHash struct {
	GetAppHash *ResponseGetAppHash `protobuf:"bytes,17,opt,name=get_app_hash,json=getAppHash,proto3,oneof" json:"get_app_hash,omitempty"`
}
type Response_GenerateFraudProof struct {
	GenerateFraudProof *ResponseGenerateFraudProof `protobuf:"bytes,18,opt,name=generate_fraud_proof,json=generateFraudProof,proto3,oneof" json:"generate_fraud_proof,omitempty"`
}
type Response_VerifyFraudProof struct {
	VerifyFraudProof *ResponseVerifyFraudProof `protobuf:"bytes,19,opt,name=verify_fraud_proof,json=verifyFraudProof,proto3,oneof" json:"verify_fraud_proof,omitempty"`
}

func (*Response_Exception) isResponse_Value()          {}
func (*Response_Echo) isResponse_Value()               {}
func (*Response_Flush) isResponse_Value()              {}
func (*Response_Info) isResponse_Value()               {}
func (*Response_SetOption) isResponse_Value()          {}
func (*Response_InitChain) isResponse_Value()          {}
func (*Response_Query) isResponse_Value()              {}
func (*Response_BeginBlock) isResponse_Value()         {}
func (*Response_CheckTx) isResponse_Value()            {}
func (*Response_DeliverTx) isResponse_Value()          {}
func (*Response_EndBlock) isResponse_Value()           {}
func (*Response_Commit) isResponse_Value()             {}
func (*Response_ListSnapshots) isResponse_Value()      {}
func (*Response_OfferSnapshot) isResponse_Value()      {}
func (*Response_LoadSnapshotChunk) isResponse_Value()  {}
func (*Response_ApplySnapshotChunk) isResponse_Value() {}
func (*Response_GetAppHash) isResponse_Value()         {}
func (*Response_GenerateFraudProof) isResponse_Value() {}
func (*Response_VerifyFraudProof) isResponse_Value()   {}

func (m *Response) GetValue() isResponse_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Response) GetException() *types.ResponseException {
	if x, ok := m.GetValue().(*Response_Exception); ok {
		return x.Exception
	}
	return nil
}

func (m *Response) GetEcho() *types.ResponseEcho {
	if x, ok := m.GetValue().(*Response_Echo); ok {
		return x.Echo
	}
	return nil
}

func (m *Response) GetFlush() *types.ResponseFlush {
	if x, ok := m.GetValue().(*Response_Flush); ok {
		return x.Flush
	}
	return nil
}

func (m *Response) GetInfo() *types.ResponseInfo {
	if x, ok := m.GetValue().(*Response_Info); ok {
		return x.Info
	}
	return nil
}

func (m *Response) GetSetOption() *types.ResponseSetOption {
	if x, ok := m.GetValue().(*Response_SetOption); ok {
		return x.SetOption
	}
	return nil
}

func (m *Response) GetInitChain() *types.ResponseInitChain {
	if x, ok := m.GetValue().(*Response_InitChain); ok {
		return x.InitChain
	}
	return nil
}

func (m *Response) GetQuery() *types.ResponseQuery {
	if x, ok := m.GetValue().(*Response_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Response) GetBeginBlock() *types.ResponseBeginBlock {
	if x, ok := m.GetValue().(*Response_BeginBlock); ok {
		return x.BeginBlock
	}
	return nil
}

func (m *Response) GetCheckTx() *types.ResponseCheckTx {
	if x, ok := m.GetValue().(*Response_CheckTx); ok {
		return x.CheckTx
	}
	return nil
}

func (m *Response) GetDeliverTx() *types.ResponseDeliverTx {
	if x, ok := m.GetValue().(*Response_DeliverTx); ok {
		return x.DeliverTx
	}
	return nil
}

func (m *Response) GetEndBlock() *types.ResponseEndBlock {
	if x, ok := m.GetValue().(*Response_EndBlock); ok {
		return x.EndBlock
	}
	return nil
}

func (m *Response) GetCommit() *types.ResponseCommit {
	if x, ok := m.GetValue().(*Response_Commit); ok {
		return x.Commit
	}
	return nil
}

func (m *Response) GetListSnapshots() *types.ResponseListSnapshots {
	if x, ok := m.GetValue().(*Response_ListSnapshots); ok {
		return x.ListSnapshots
	}
	return nil
}

func (m *Response) GetOfferSnapshot() *types.ResponseOfferSnapshot {
	if x, ok := m.GetValue().(*Response_OfferSnapshot); ok {
		return x.OfferSnapshot
	}
	return nil
}

func (m *Response) GetLoadSnapshotChunk() *types.ResponseLoadSnapshotChunk {
	if x, ok := m.GetValue().(*Response_LoadSnapshotChunk); ok {
		return x.LoadSnapshotChunk
	}
	return nil
}

func (m *Response) GetApplySnapshotChunk() *types.ResponseApplySnapshotChunk {
	if x, ok := m.GetValue().(*Response_ApplySnapshotChunk); ok {
		return x.ApplySnapshotChunk
	}
	return nil
}

func (m *Response) GetGetAppHash() *ResponseGetAppHash {
	if x, ok := m.GetValue().(*Response_GetAppHash); ok {
		return x.GetAppHash
	}
	return nil
}

func (m *Response) GetGenerateFraudProof() *ResponseGenerateFraudProof {
	if x, ok := m.GetValue().(*Response_GenerateFraudProof); ok {
		return x.GenerateFraudProof
	}
	return nil
}

func (m *Response) GetVerifyFraudProof() *ResponseVerifyFraudProof {
	if x, ok := m.GetValue().(*Response_VerifyFraudProof); ok {
		return x.VerifyFraudProof
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Response) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Response_Exception)(nil),
		(*Response_Echo)(nil),
		(*Response_Flush)(nil),
		(*Response_Info)(nil),
		(*Response_SetOption)(nil),
		(*Response_InitChain)(nil),
		(*Response_Query)(nil),
		(*Response_BeginBlock)(nil),
		(*Response_CheckTx)(nil),
		(*Response_DeliverTx)(nil),
		(*Response_EndBlock)(nil),
		(*Response_Commit)(nil),
		(*Response_ListSnapshots)(nil),
		(*Response_OfferSnapshot)(nil),
		(*Response_LoadSnapshotChunk)(nil),
		(*Response_ApplySnapshotChunk)(nil),
		(*Response_GetAppHash)(nil),
		(*Response_GenerateFraudProof)(nil),
		(*Response_VerifyFraudProof)(nil),
	}
}

type ResponseGetAppHash struct {
	AppHash []byte `protobuf:"bytes,1,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
}

func (m *ResponseGetAppHash) Reset()         { *m = ResponseGetAppHash{} }
func (m *ResponseGetAppHash) String() string { return proto.CompactTextString(m) }
func (*ResponseGetAppHash) ProtoMessage()    {}
func (*ResponseGetAppHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{5}
}
func (m *ResponseGetAppHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseGetAppHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseGetAppHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseGetAppHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseGetAppHash.Merge(m, src)
}
func (m *ResponseGetAppHash) XXX_Size() int {
	return m.Size()
}
func (m *ResponseGetAppHash) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseGetAppHash.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseGetAppHash proto.InternalMessageInfo

func (m *ResponseGetAppHash) GetAppHash() []byte {
	if m != nil {
		return m.AppHash
	}
	return nil
}

type ResponseGenerateFraudProof struct {
	FraudProof *FraudProof `protobuf:"bytes,1,opt,name=fraud_proof,json=fraudProof,proto3" json:"fraud_proof,omitempty"`
}

func (m *ResponseGenerateFraudProof) Reset()         { *m = ResponseGenerateFraudProof{} }
func (m *ResponseGenerateFraudProof) String() string { return proto.CompactTextString(m) }
func (*ResponseGenerateFraudProof) ProtoMessage()    {}
func (*ResponseGenerateFraudProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{6}
}
func (m *ResponseGenerateFraudProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseGenerateFraudProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseGenerateFraudProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseGenerateFraudProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseGenerateFraudProof.Merge(m, src)
}
func (m *ResponseGenerateFraudProof) XXX_Size() int {
	return m.Size()
}
func (m *ResponseGenerateFraudProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseGenerateFraudProof.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseGenerateFraudProof proto.InternalMessageInfo

func (m *ResponseGenerateFraudProof) GetFraudProof() *FraudProof {
	if m != nil {
		return m.FraudProof
	}
	return nil
}

type ResponseVerifyFraudProof struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *ResponseVerifyFraudProof) Reset()         { *m = ResponseVerifyFraudProof{} }
func (m *ResponseVerifyFraudProof) String() string { return proto.CompactTextString(m) }
func (*ResponseVerifyFraudProof) ProtoMessage()    {}
func (*ResponseVerifyFraudProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{7}
}
func (m *ResponseVerifyFraudProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseVerifyFraudProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseVerifyFraudProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseVerifyFraudProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseVerifyFraudProof.Merge(m, src)
}
func (m *ResponseVerifyFraudProof) XXX_Size() int {
	return m.Size()
}
func (m *ResponseVerifyFraudProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseVerifyFraudProof.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseVerifyFraudProof proto.InternalMessageInfo

func (m *ResponseVerifyFraudProof) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// Represents a single-round fraudProof
type FraudProof struct {
	BlockHeight          int64                    `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	PreStateAppHash      []byte                   `protobuf:"bytes,2,opt,name=pre_state_app_hash,json=preStateAppHash,proto3" json:"pre_state_app_hash,omitempty"`
	ExpectedValidAppHash []byte                   `protobuf:"bytes,3,opt,name=expected_valid_app_hash,json=expectedValidAppHash,proto3" json:"expected_valid_app_hash,omitempty"`
	StateWitness         map[string]*StateWitness `protobuf:"bytes,4,rep,name=state_witness,json=stateWitness,proto3" json:"state_witness,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FraudulentBeginBlock *types.RequestBeginBlock `protobuf:"bytes,5,opt,name=fraudulent_begin_block,json=fraudulentBeginBlock,proto3" json:"fraudulent_begin_block,omitempty"`
	FraudulentDeliverTx  *types.RequestDeliverTx  `protobuf:"bytes,6,opt,name=fraudulent_deliver_tx,json=fraudulentDeliverTx,proto3" json:"fraudulent_deliver_tx,omitempty"`
	FraudulentEndBlock   *types.RequestEndBlock   `protobuf:"bytes,7,opt,name=fraudulent_end_block,json=fraudulentEndBlock,proto3" json:"fraudulent_end_block,omitempty"`
}

func (m *FraudProof) Reset()         { *m = FraudProof{} }
func (m *FraudProof) String() string { return proto.CompactTextString(m) }
func (*FraudProof) ProtoMessage()    {}
func (*FraudProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{8}
}
func (m *FraudProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FraudProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FraudProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FraudProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FraudProof.Merge(m, src)
}
func (m *FraudProof) XXX_Size() int {
	return m.Size()
}
func (m *FraudProof) XXX_DiscardUnknown() {
	xxx_messageInfo_FraudProof.DiscardUnknown(m)
}

var xxx_messageInfo_FraudProof proto.InternalMessageInfo

func (m *FraudProof) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *FraudProof) GetPreStateAppHash() []byte {
	if m != nil {
		return m.PreStateAppHash
	}
	return nil
}

func (m *FraudProof) GetExpectedValidAppHash() []byte {
	if m != nil {
		return m.ExpectedValidAppHash
	}
	return nil
}

func (m *FraudProof) GetStateWitness() map[string]*StateWitness {
	if m != nil {
		return m.StateWitness
	}
	return nil
}

func (m *FraudProof) GetFraudulentBeginBlock() *types.RequestBeginBlock {
	if m != nil {
		return m.FraudulentBeginBlock
	}
	return nil
}

func (m *FraudProof) GetFraudulentDeliverTx() *types.RequestDeliverTx {
	if m != nil {
		return m.FraudulentDeliverTx
	}
	return nil
}

func (m *FraudProof) GetFraudulentEndBlock() *types.RequestEndBlock {
	if m != nil {
		return m.FraudulentEndBlock
	}
	return nil
}

// State witness with a list of all witness data
type StateWitness struct {
	// store level proof
	Proof *crypto.ProofOp `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// substore level hash
	RootHash []byte `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// List of witness data
	WitnessData []*WitnessData `protobuf:"bytes,3,rep,name=witness_data,json=witnessData,proto3" json:"witness_data,omitempty"`
}

func (m *StateWitness) Reset()         { *m = StateWitness{} }
func (m *StateWitness) String() string { return proto.CompactTextString(m) }
func (*StateWitness) ProtoMessage()    {}
func (*StateWitness) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{9}
}
func (m *StateWitness) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateWitness) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateWitness.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateWitness) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateWitness.Merge(m, src)
}
func (m *StateWitness) XXX_Size() int {
	return m.Size()
}
func (m *StateWitness) XXX_DiscardUnknown() {
	xxx_messageInfo_StateWitness.DiscardUnknown(m)
}

var xxx_messageInfo_StateWitness proto.InternalMessageInfo

func (m *StateWitness) GetProof() *crypto.ProofOp {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *StateWitness) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *StateWitness) GetWitnessData() []*WitnessData {
	if m != nil {
		return m.WitnessData
	}
	return nil
}

// Witness data containing a key/value pair and a Merkle proof for said key/value pair
type WitnessData struct {
	Operation Operation         `protobuf:"varint,1,opt,name=operation,proto3,enum=rollkit.abci.Operation" json:"operation,omitempty"`
	Key       []byte            `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value     []byte            `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Proofs    []*crypto.ProofOp `protobuf:"bytes,4,rep,name=proofs,proto3" json:"proofs,omitempty"`
}

func (m *WitnessData) Reset()         { *m = WitnessData{} }
func (m *WitnessData) String() string { return proto.CompactTextString(m) }
func (*WitnessData) ProtoMessage()    {}
func (*WitnessData) Descriptor() ([]byte, []int) {
	return fileDescriptor_766c6a8befeeae04, []int{10}
}
func (m *WitnessData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WitnessData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WitnessData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WitnessData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WitnessData.Merge(m, src)
}
func (m *WitnessData) XXX_Size() int {
	return m.Size()
}
func (m *WitnessData) XXX_DiscardUnknown() {
	xxx_messageInfo_WitnessData.DiscardUnknown(m)
}

var xxx_messageInfo_WitnessData proto.InternalMessageInfo

func (m *WitnessData) GetOperation() Operation {
	if m != nil {
		return m.Operation
	}
	return Operation_write
}

func (m *WitnessData) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WitnessData) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *WitnessData) GetProofs() []*crypto.ProofOp {
	if m != nil {
		return m.Proofs
	}
	return nil
}

func init() {
	proto.RegisterEnum("rollkit.abci.Operation", Operation_name, Operation_value)
	proto.RegisterType((*Request)(nil), "rollkit.abci.Request")
	proto.RegisterType((*RequestGetAppHash)(nil), "rollkit.abci.RequestGetAppHash")
	proto.RegisterType((*RequestGenerateFraudProof)(nil), "rollkit.abci.RequestGenerateFraudProof")
	proto.RegisterType((*RequestVerifyFraudProof)(nil), "rollkit.abci.RequestVerifyFraudProof")
	proto.RegisterType((*Response)(nil), "rollkit.abci.Response")
	proto.RegisterType((*ResponseGetAppHash)(nil), "rollkit.abci.ResponseGetAppHash")
	proto.RegisterType((*ResponseGenerateFraudProof)(nil), "rollkit.abci.ResponseGenerateFraudProof")
	proto.RegisterType((*ResponseVerifyFraudProof)(nil), "rollkit.abci.ResponseVerifyFraudProof")
	proto.RegisterType((*FraudProof)(nil), "rollkit.abci.FraudProof")
	proto.RegisterMapType((map[string]*StateWitness)(nil), "rollkit.abci.FraudProof.StateWitnessEntry")
	proto.RegisterType((*StateWitness)(nil), "rollkit.abci.StateWitness")
	proto.RegisterType((*WitnessData)(nil), "rollkit.abci.WitnessData")
}

func init() { proto.RegisterFile("rollkit/abci/types.proto", fileDescriptor_766c6a8befeeae04) }

var fileDescriptor_766c6a8befeeae04 = []byte{
	// 1403 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x98, 0x4d, 0x6f, 0xdb, 0x36,
	0x18, 0xc7, 0xe5, 0xd8, 0xf1, 0xcb, 0x63, 0x37, 0x8d, 0x99, 0xac, 0x55, 0xdd, 0xd5, 0x4d, 0x3d,
	0x74, 0xeb, 0x5a, 0xc0, 0x1e, 0xd2, 0xb5, 0x68, 0x87, 0x0e, 0x5d, 0xed, 0xb8, 0x73, 0x81, 0x6e,
	0x5e, 0xd9, 0x57, 0xac, 0xc5, 0x04, 0x45, 0xa2, 0x6d, 0x21, 0x8a, 0xa4, 0x4a, 0x74, 0x1a, 0x7f,
	0x85, 0xec, 0xb2, 0xd3, 0x2e, 0x43, 0x81, 0x7d, 0x9a, 0xa1, 0xc7, 0x1e, 0x77, 0x1a, 0xb6, 0xe6,
	0x8b, 0x0c, 0x24, 0x25, 0x4b, 0xb6, 0x43, 0xdb, 0xc3, 0x6e, 0x22, 0xf9, 0x7f, 0xfe, 0xe4, 0x43,
	0x3e, 0xe4, 0x2f, 0x31, 0xa8, 0xbe, 0x6b, 0xdb, 0x7b, 0x16, 0x6d, 0xe8, 0xbb, 0x86, 0xd5, 0xa0,
	0x23, 0x8f, 0x04, 0x75, 0xcf, 0x77, 0xa9, 0x8b, 0x4a, 0xe1, 0x48, 0x9d, 0x8d, 0x54, 0x2e, 0x50,
	0xe2, 0x98, 0xc4, 0xdf, 0xb7, 0x1c, 0xda, 0x30, 0xfc, 0x91, 0x47, 0xdd, 0x86, 0xe7, 0xbb, 0x6e,
	0x4f, 0x88, 0x2b, 0xe7, 0x13, 0xc3, 0xd3, 0x4e, 0x95, 0xcd, 0xbe, 0xdb, 0x77, 0xf9, 0x67, 0x83,
	0x7d, 0x89, 0xde, 0xda, 0x11, 0x40, 0x0e, 0x93, 0xd7, 0x43, 0x12, 0x50, 0xb4, 0x0d, 0x19, 0x62,
	0x0c, 0x5c, 0x35, 0xb5, 0x95, 0xba, 0x52, 0xdc, 0xfe, 0xb8, 0x1e, 0xbb, 0xf1, 0xd9, 0xeb, 0xa1,
	0xae, 0x6d, 0x0c, 0xdc, 0x8e, 0x82, 0xb9, 0x16, 0xdd, 0x80, 0xd5, 0x9e, 0x3d, 0x0c, 0x06, 0xea,
	0x0a, 0x0f, 0xba, 0x20, 0x0b, 0xba, 0xcf, 0x44, 0x1d, 0x05, 0x0b, 0x35, 0x9b, 0xca, 0x72, 0x7a,
	0xae, 0x9a, 0x9e, 0x3f, 0xd5, 0x03, 0xa7, 0xc7, 0xa7, 0x62, 0x5a, 0xd4, 0x04, 0x08, 0x08, 0xd5,
	0x5c, 0x8f, 0x5a, 0xae, 0xa3, 0x66, 0x78, 0xe4, 0x25, 0x59, 0xe4, 0x63, 0x42, 0xbb, 0x5c, 0xd8,
	0x51, 0x70, 0x21, 0x88, 0x1a, 0xcc, 0xc3, 0x72, 0x2c, 0xaa, 0x19, 0x03, 0xdd, 0x72, 0xd4, 0xd5,
	0xf9, 0x1e, 0x0f, 0x1c, 0x8b, 0xb6, 0x98, 0x90, 0x79, 0x58, 0x51, 0x83, 0xa5, 0xfc, 0x7a, 0x48,
	0xfc, 0x91, 0x9a, 0x9d, 0x9f, 0xf2, 0x23, 0x26, 0x62, 0x29, 0x73, 0x35, 0x6a, 0x43, 0x71, 0x97,
	0xf4, 0x2d, 0x47, 0xdb, 0xb5, 0x5d, 0x63, 0x4f, 0xcd, 0xf1, 0xe0, 0x9a, 0x2c, 0xb8, 0xc9, 0xa4,
	0x4d, 0xa6, 0xec, 0x28, 0x18, 0x76, 0xc7, 0x2d, 0x74, 0x07, 0xf2, 0xc6, 0x80, 0x18, 0x7b, 0x1a,
	0x3d, 0x54, 0xf3, 0xdc, 0xe3, 0xa2, 0xcc, 0xa3, 0xc5, 0x74, 0x4f, 0x0e, 0x3b, 0x0a, 0xce, 0x19,
	0xe2, 0x93, 0xe5, 0x6f, 0x12, 0xdb, 0x3a, 0x20, 0x3e, 0x8b, 0x2f, 0xcc, 0xcf, 0x7f, 0x47, 0x28,
	0xb9, 0x43, 0xc1, 0x8c, 0x1a, 0xe8, 0x2e, 0x14, 0x88, 0x63, 0x86, 0x69, 0x00, 0xb7, 0xd8, 0x92,
	0xd6, 0x8a, 0x63, 0x46, 0x49, 0xe4, 0x49, 0xf8, 0x8d, 0x6e, 0x41, 0xd6, 0x70, 0xf7, 0xf7, 0x2d,
	0xaa, 0x16, 0x79, 0x74, 0x55, 0x9a, 0x00, 0x57, 0x75, 0x14, 0x1c, 0xea, 0xd1, 0xf7, 0xb0, 0x66,
	0x5b, 0x01, 0xd5, 0x02, 0x47, 0xf7, 0x82, 0x81, 0x4b, 0x03, 0xb5, 0xc4, 0x1d, 0x2e, 0xcb, 0x1c,
	0x1e, 0x5a, 0x01, 0x7d, 0x1c, 0x89, 0x3b, 0x0a, 0x3e, 0x65, 0x27, 0x3b, 0x98, 0x9f, 0xdb, 0xeb,
	0x11, 0x7f, 0x6c, 0xa8, 0x9e, 0x9a, 0xef, 0xd7, 0x65, 0xea, 0x28, 0x9e, 0xf9, 0xb9, 0xc9, 0x0e,
	0xf4, 0x12, 0x36, 0x6c, 0x57, 0x37, 0xc7, 0x76, 0x9a, 0x31, 0x18, 0x3a, 0x7b, 0xea, 0x1a, 0x37,
	0xfd, 0x5c, 0xba, 0x48, 0x57, 0x37, 0x23, 0x8b, 0x16, 0x0b, 0xe8, 0x28, 0xb8, 0x6c, 0x4f, 0x77,
	0xa2, 0x9f, 0x60, 0x53, 0xf7, 0x3c, 0x7b, 0x34, 0xed, 0x7e, 0x9a, 0xbb, 0x5f, 0x95, 0xb9, 0xdf,
	0x63, 0x31, 0xd3, 0xf6, 0x48, 0x9f, 0xe9, 0x45, 0x2d, 0x28, 0xf5, 0x09, 0xd5, 0x74, 0xcf, 0xd3,
	0x06, 0x7a, 0x30, 0x50, 0xd7, 0xc3, 0xea, 0x4a, 0xbe, 0x40, 0x91, 0xe9, 0xb7, 0x84, 0xf9, 0x76,
	0x74, 0x7e, 0xa7, 0xa1, 0x3f, 0x6e, 0xa1, 0x97, 0xb0, 0xd9, 0x27, 0x0e, 0xf1, 0x75, 0x4a, 0xb4,
	0x9e, 0xaf, 0x0f, 0x4d, 0x8d, 0x3f, 0x50, 0x6a, 0x99, 0x9b, 0x7d, 0x26, 0x31, 0x13, 0x01, 0xf7,
	0x99, 0xfe, 0x07, 0x26, 0x67, 0x2b, 0xec, 0xcf, 0xf4, 0xa2, 0xa7, 0x80, 0x0e, 0x88, 0x6f, 0xf5,
	0x46, 0x13, 0xd6, 0x28, 0x3c, 0xb2, 0x93, 0xac, 0x9f, 0x71, 0xf9, 0x84, 0xf1, 0xfa, 0xc1, 0x54,
	0x5f, 0x33, 0x07, 0xab, 0x07, 0xba, 0x3d, 0x24, 0xb5, 0x0d, 0x28, 0xcf, 0xe4, 0x57, 0xfb, 0x75,
	0x05, 0xce, 0x49, 0x17, 0x8a, 0x5e, 0xc0, 0x46, 0xe2, 0x56, 0x6b, 0xbe, 0x10, 0x86, 0x4f, 0xe8,
	0x12, 0xb7, 0xbb, 0x99, 0x79, 0xf7, 0xd7, 0x45, 0x05, 0x97, 0xe3, 0x1b, 0x1e, 0xbd, 0xc6, 0x8f,
	0x60, 0x23, 0xbe, 0xaa, 0x91, 0x71, 0xa0, 0xae, 0x6c, 0xa5, 0x97, 0xba, 0xb3, 0xb8, 0x3c, 0xbe,
	0xb1, 0xe1, 0x50, 0x80, 0x1e, 0x42, 0x79, 0x7c, 0x73, 0xc7, 0x4b, 0x4d, 0x2f, 0x77, 0x83, 0xf1,
	0xe9, 0xe8, 0xfe, 0x86, 0x03, 0xb5, 0x9f, 0x53, 0x70, 0x56, 0xb2, 0xcd, 0xe8, 0x36, 0x14, 0x93,
	0x47, 0x24, 0xb6, 0x43, 0x9d, 0x3c, 0xa2, 0x58, 0x8e, 0xa1, 0x17, 0x87, 0xde, 0x80, 0xb3, 0xe4,
	0xd0, 0x23, 0x06, 0x25, 0xa6, 0x76, 0xa0, 0xdb, 0x96, 0x19, 0x57, 0x24, 0x63, 0x4c, 0x09, 0x6f,
	0x46, 0xc3, 0xcf, 0xd8, 0x68, 0x74, 0x4c, 0xff, 0x00, 0xe4, 0x31, 0x09, 0x3c, 0xd7, 0x09, 0x08,
	0x6a, 0x42, 0x81, 0x1c, 0x1a, 0x44, 0x90, 0x42, 0x7e, 0x16, 0x42, 0xdd, 0x8e, 0x94, 0xec, 0x99,
	0x1b, 0x87, 0xa1, 0xeb, 0x21, 0x0d, 0xe5, 0x60, 0x0b, 0xc3, 0x93, 0x38, 0xbc, 0x19, 0xe1, 0x30,
	0x2d, 0x7d, 0xd9, 0x44, 0xd4, 0x14, 0x0f, 0xaf, 0x87, 0x3c, 0xcc, 0x2c, 0x98, 0x6c, 0x02, 0x88,
	0xad, 0x09, 0x20, 0xae, 0x2e, 0x48, 0x53, 0x42, 0xc4, 0xd6, 0x04, 0x11, 0xb3, 0x0b, 0x4c, 0x24,
	0x48, 0xbc, 0x19, 0x21, 0x31, 0xb7, 0x20, 0xed, 0x29, 0x26, 0xde, 0x9f, 0x64, 0xa2, 0xe0, 0xd9,
	0x27, 0xd2, 0x68, 0x29, 0x14, 0xbf, 0x4e, 0x40, 0xb1, 0x20, 0xad, 0x67, 0x61, 0x72, 0x02, 0x15,
	0x5b, 0x13, 0x54, 0x84, 0x05, 0x7b, 0x20, 0xc1, 0xe2, 0x37, 0x49, 0x2c, 0x16, 0xa5, 0x64, 0x0d,
	0x8b, 0xe6, 0x24, 0x2e, 0xde, 0x1e, 0x73, 0xb1, 0x24, 0x05, 0x7b, 0x98, 0xc3, 0x34, 0x18, 0xbb,
	0x33, 0x60, 0x14, 0x20, 0xfb, 0x54, 0x6a, 0xb1, 0x80, 0x8c, 0xdd, 0x19, 0x32, 0xae, 0x2d, 0x30,
	0x5c, 0x80, 0xc6, 0x57, 0x27, 0xa3, 0x51, 0x0e, 0xaf, 0x70, 0x99, 0xcb, 0xb1, 0x51, 0x93, 0xb0,
	0x51, 0x30, 0xec, 0x9a, 0xd4, 0x7e, 0x69, 0x38, 0xee, 0x4c, 0xc1, 0xb1, 0x1c, 0x56, 0xd9, 0x14,
	0x74, 0x84, 0xab, 0x94, 0x8e, 0xaf, 0x24, 0x74, 0x14, 0x08, 0xbb, 0x22, 0x73, 0x5b, 0x12, 0x8f,
	0xcf, 0x4e, 0xc4, 0xe3, 0x46, 0x78, 0x6e, 0x27, 0x7a, 0xff, 0x37, 0x3e, 0x36, 0x00, 0xcd, 0xa6,
	0x88, 0xce, 0x41, 0x7e, 0xbc, 0x2d, 0x29, 0xfe, 0x42, 0xe7, 0xf4, 0xf0, 0x51, 0x7e, 0x0e, 0x15,
	0x79, 0x16, 0xff, 0x03, 0x12, 0xb5, 0x2f, 0x41, 0x95, 0xa5, 0x80, 0x54, 0xc8, 0x05, 0x43, 0xc3,
	0x20, 0x41, 0xc0, 0x2d, 0xf3, 0x38, 0x6a, 0xd6, 0xfe, 0xc8, 0x00, 0x24, 0x84, 0x97, 0xa0, 0x24,
	0x50, 0x38, 0x20, 0x56, 0x7f, 0x20, 0xa0, 0x9d, 0xc6, 0x45, 0xde, 0xd7, 0xe1, 0x5d, 0xe8, 0x1a,
	0x20, 0xcf, 0x27, 0x5a, 0x40, 0xd9, 0x89, 0x4d, 0x71, 0xe8, 0xb4, 0xe7, 0x93, 0xc7, 0x6c, 0x20,
	0xda, 0x88, 0x39, 0xe4, 0x4a, 0xcb, 0xc9, 0x85, 0xba, 0x70, 0x4a, 0xf8, 0xbf, 0xb1, 0xa8, 0xc3,
	0x56, 0x9d, 0xe1, 0x88, 0xbf, 0x2a, 0xdb, 0x88, 0x3a, 0x9f, 0xf4, 0xb9, 0x10, 0xb7, 0x1d, 0xea,
	0x8f, 0x70, 0x29, 0x48, 0x74, 0xa1, 0x17, 0x70, 0x86, 0x6f, 0xd5, 0xd0, 0x26, 0x0e, 0xd5, 0x92,
	0x0f, 0xec, 0xea, 0xb2, 0x7f, 0x96, 0xe0, 0xcd, 0xd8, 0x21, 0xee, 0x45, 0x4f, 0xe1, 0xa3, 0x84,
	0x73, 0xe2, 0xcd, 0xcc, 0x2e, 0xf9, 0x9f, 0x04, 0xde, 0x88, 0xe3, 0xc7, 0x9d, 0x08, 0x43, 0x62,
	0x3a, 0x2d, 0x7e, 0x45, 0x73, 0x4b, 0xfe, 0x69, 0x82, 0xe2, 0xe8, 0xa8, 0xaf, 0xf2, 0x12, 0xca,
	0x33, 0xfb, 0x84, 0xd6, 0x21, 0xbd, 0x47, 0x46, 0xfc, 0xa0, 0x0b, 0x98, 0x7d, 0xa2, 0x2f, 0xc2,
	0xda, 0x0e, 0x31, 0x5f, 0x99, 0xdc, 0xf4, 0xa4, 0x03, 0x16, 0xc2, 0xaf, 0x56, 0x6e, 0xa5, 0x6a,
	0xbf, 0xa5, 0xa0, 0x94, 0x1c, 0x63, 0x36, 0xc9, 0x22, 0xae, 0x24, 0x97, 0x2c, 0xfe, 0x51, 0xaf,
	0xf3, 0xb3, 0xeb, 0x7a, 0x58, 0x08, 0xd1, 0x79, 0x28, 0xf8, 0xae, 0x4b, 0x93, 0x05, 0x95, 0x67,
	0x1d, 0xbc, 0x24, 0xee, 0x40, 0x29, 0x2c, 0x06, 0xcd, 0xd4, 0xa9, 0xae, 0xa6, 0x79, 0x45, 0x9c,
	0x9b, 0x5c, 0x5c, 0x38, 0xf7, 0x8e, 0x4e, 0x75, 0x5c, 0x7c, 0x13, 0x37, 0x6a, 0xbf, 0xa7, 0xa0,
	0x98, 0x18, 0x44, 0x37, 0xa0, 0xe0, 0x7a, 0xec, 0xf2, 0x45, 0x7f, 0x0d, 0xad, 0x6d, 0x9f, 0x9d,
	0xb4, 0xea, 0x46, 0xc3, 0x38, 0x56, 0x46, 0x9b, 0x25, 0xd6, 0xc6, 0x37, 0x6b, 0x33, 0xda, 0x2c,
	0x51, 0xce, 0xa2, 0x81, 0xb6, 0x21, 0xcb, 0x53, 0x8a, 0x0a, 0x77, 0x5e, 0xf2, 0xa1, 0xf2, 0xea,
	0x77, 0x50, 0x18, 0xcf, 0xc9, 0x6c, 0x9f, 0xe3, 0x07, 0x4f, 0xda, 0xeb, 0x4a, 0xa5, 0x70, 0xf4,
	0x76, 0x6b, 0xf5, 0x8d, 0x6f, 0x51, 0x82, 0x10, 0x64, 0x70, 0xfb, 0xde, 0xce, 0x7a, 0xaa, 0x92,
	0x3f, 0x7a, 0xbb, 0x95, 0xf1, 0x89, 0x6e, 0xa2, 0x33, 0x90, 0xdd, 0x69, 0x3f, 0x6c, 0x3f, 0x69,
	0xaf, 0xaf, 0x54, 0xe0, 0xe8, 0xed, 0x56, 0xd6, 0x24, 0x36, 0xa1, 0xa4, 0x79, 0xf7, 0xdd, 0x87,
	0x6a, 0xea, 0xfd, 0x87, 0x6a, 0xea, 0xef, 0x0f, 0xd5, 0xd4, 0x2f, 0xc7, 0x55, 0xe5, 0xfd, 0x71,
	0x55, 0xf9, 0xf3, 0xb8, 0xaa, 0xfc, 0x78, 0xb9, 0x6f, 0xd1, 0xc1, 0x70, 0xb7, 0x6e, 0xb8, 0xfb,
	0x8d, 0xe8, 0x47, 0x96, 0xd9, 0x1f, 0x5b, 0x76, 0xb3, 0xfc, 0xd7, 0x90, 0xeb, 0xff, 0x06, 0x00,
	0x00, 0xff, 0xff, 0x41, 0xa8, 0xbc, 0xf2, 0x89, 0x11, 0x00, 0x00,
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Request_Echo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Echo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Echo != nil {
		{
			size, err := m.Echo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Request_Flush) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Flush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flush != nil {
		{
			size, err := m.Flush.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Request_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Request_SetOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_SetOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetOption != nil {
		{
			size, err := m.SetOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Request_InitChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_InitChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InitChain != nil {
		{
			size, err := m.InitChain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Request_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Request_BeginBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_BeginBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BeginBlock != nil {
		{
			size, err := m.BeginBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Request_CheckTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_CheckTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckTx != nil {
		{
			size, err := m.CheckTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Request_DeliverTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_DeliverTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeliverTx != nil {
		{
			size, err := m.DeliverTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Request_EndBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_EndBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EndBlock != nil {
		{
			size, err := m.EndBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Request_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Request_ListSnapshots) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_ListSnapshots) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ListSnapshots != nil {
		{
			size, err := m.ListSnapshots.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Request_OfferSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_OfferSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OfferSnapshot != nil {
		{
			size, err := m.OfferSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Request_LoadSnapshotChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_LoadSnapshotChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoadSnapshotChunk != nil {
		{
			size, err := m.LoadSnapshotChunk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Request_ApplySnapshotChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_ApplySnapshotChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ApplySnapshotChunk != nil {
		{
			size, err := m.ApplySnapshotChunk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Request_GetAppHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_GetAppHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GetAppHash != nil {
		{
			size, err := m.GetAppHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Request_GenerateFraudProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_GenerateFraudProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GenerateFraudProof != nil {
		{
			size, err := m.GenerateFraudProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Request_VerifyFraudProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_VerifyFraudProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VerifyFraudProof != nil {
		{
			size, err := m.VerifyFraudProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *RequestGetAppHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGetAppHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGetAppHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RequestGenerateFraudProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGenerateFraudProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGenerateFraudProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndBlockRequest != nil {
		{
			size, err := m.EndBlockRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeliverTxRequests) > 0 {
		for iNdEx := len(m.DeliverTxRequests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeliverTxRequests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.BeginBlockRequest.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RequestVerifyFraudProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVerifyFraudProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestVerifyFraudProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExpectedValidAppHash) > 0 {
		i -= len(m.ExpectedValidAppHash)
		copy(dAtA[i:], m.ExpectedValidAppHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExpectedValidAppHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.FraudProof != nil {
		{
			size, err := m.FraudProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response_Exception) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Exception) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Exception != nil {
		{
			size, err := m.Exception.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Response_Echo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Echo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Echo != nil {
		{
			size, err := m.Echo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Response_Flush) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Flush) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flush != nil {
		{
			size, err := m.Flush.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Response_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Response_SetOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_SetOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetOption != nil {
		{
			size, err := m.SetOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Response_InitChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_InitChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InitChain != nil {
		{
			size, err := m.InitChain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Response_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Response_BeginBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_BeginBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BeginBlock != nil {
		{
			size, err := m.BeginBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Response_CheckTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_CheckTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckTx != nil {
		{
			size, err := m.CheckTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Response_DeliverTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_DeliverTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeliverTx != nil {
		{
			size, err := m.DeliverTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Response_EndBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_EndBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EndBlock != nil {
		{
			size, err := m.EndBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Response_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Response_ListSnapshots) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_ListSnapshots) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ListSnapshots != nil {
		{
			size, err := m.ListSnapshots.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Response_OfferSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_OfferSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OfferSnapshot != nil {
		{
			size, err := m.OfferSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Response_LoadSnapshotChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_LoadSnapshotChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoadSnapshotChunk != nil {
		{
			size, err := m.LoadSnapshotChunk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Response_ApplySnapshotChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_ApplySnapshotChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ApplySnapshotChunk != nil {
		{
			size, err := m.ApplySnapshotChunk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Response_GetAppHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_GetAppHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GetAppHash != nil {
		{
			size, err := m.GetAppHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Response_GenerateFraudProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_GenerateFraudProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GenerateFraudProof != nil {
		{
			size, err := m.GenerateFraudProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Response_VerifyFraudProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_VerifyFraudProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VerifyFraudProof != nil {
		{
			size, err := m.VerifyFraudProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseGetAppHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseGetAppHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseGetAppHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppHash) > 0 {
		i -= len(m.AppHash)
		copy(dAtA[i:], m.AppHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseGenerateFraudProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseGenerateFraudProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseGenerateFraudProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FraudProof != nil {
		{
			size, err := m.FraudProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseVerifyFraudProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseVerifyFraudProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseVerifyFraudProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FraudProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FraudProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FraudProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FraudulentEndBlock != nil {
		{
			size, err := m.FraudulentEndBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.FraudulentDeliverTx != nil {
		{
			size, err := m.FraudulentDeliverTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.FraudulentBeginBlock != nil {
		{
			size, err := m.FraudulentBeginBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StateWitness) > 0 {
		for k := range m.StateWitness {
			v := m.StateWitness[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ExpectedValidAppHash) > 0 {
		i -= len(m.ExpectedValidAppHash)
		copy(dAtA[i:], m.ExpectedValidAppHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExpectedValidAppHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PreStateAppHash) > 0 {
		i -= len(m.PreStateAppHash)
		copy(dAtA[i:], m.PreStateAppHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PreStateAppHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateWitness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateWitness) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateWitness) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WitnessData) > 0 {
		for iNdEx := len(m.WitnessData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WitnessData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RootHash) > 0 {
		i -= len(m.RootHash)
		copy(dAtA[i:], m.RootHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RootHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WitnessData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WitnessData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WitnessData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proofs) > 0 {
		for iNdEx := len(m.Proofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Proofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Operation != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Request_Echo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Echo != nil {
		l = m.Echo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_Flush) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flush != nil {
		l = m.Flush.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_SetOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetOption != nil {
		l = m.SetOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_InitChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitChain != nil {
		l = m.InitChain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_BeginBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BeginBlock != nil {
		l = m.BeginBlock.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_CheckTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckTx != nil {
		l = m.CheckTx.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_DeliverTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeliverTx != nil {
		l = m.DeliverTx.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_EndBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndBlock != nil {
		l = m.EndBlock.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_ListSnapshots) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListSnapshots != nil {
		l = m.ListSnapshots.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_OfferSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OfferSnapshot != nil {
		l = m.OfferSnapshot.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_LoadSnapshotChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoadSnapshotChunk != nil {
		l = m.LoadSnapshotChunk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_ApplySnapshotChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApplySnapshotChunk != nil {
		l = m.ApplySnapshotChunk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_GetAppHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetAppHash != nil {
		l = m.GetAppHash.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_GenerateFraudProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GenerateFraudProof != nil {
		l = m.GenerateFraudProof.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Request_VerifyFraudProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerifyFraudProof != nil {
		l = m.VerifyFraudProof.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RequestGetAppHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RequestGenerateFraudProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BeginBlockRequest.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.DeliverTxRequests) > 0 {
		for _, e := range m.DeliverTxRequests {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.EndBlockRequest != nil {
		l = m.EndBlockRequest.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RequestVerifyFraudProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FraudProof != nil {
		l = m.FraudProof.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExpectedValidAppHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Response_Exception) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exception != nil {
		l = m.Exception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_Echo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Echo != nil {
		l = m.Echo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_Flush) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flush != nil {
		l = m.Flush.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_SetOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetOption != nil {
		l = m.SetOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_InitChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitChain != nil {
		l = m.InitChain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_BeginBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BeginBlock != nil {
		l = m.BeginBlock.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_CheckTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckTx != nil {
		l = m.CheckTx.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_DeliverTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeliverTx != nil {
		l = m.DeliverTx.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_EndBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndBlock != nil {
		l = m.EndBlock.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_ListSnapshots) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListSnapshots != nil {
		l = m.ListSnapshots.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_OfferSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OfferSnapshot != nil {
		l = m.OfferSnapshot.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_LoadSnapshotChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoadSnapshotChunk != nil {
		l = m.LoadSnapshotChunk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_ApplySnapshotChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApplySnapshotChunk != nil {
		l = m.ApplySnapshotChunk.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_GetAppHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetAppHash != nil {
		l = m.GetAppHash.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_GenerateFraudProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GenerateFraudProof != nil {
		l = m.GenerateFraudProof.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Response_VerifyFraudProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerifyFraudProof != nil {
		l = m.VerifyFraudProof.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ResponseGetAppHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResponseGenerateFraudProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FraudProof != nil {
		l = m.FraudProof.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResponseVerifyFraudProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *FraudProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	l = len(m.PreStateAppHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExpectedValidAppHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.StateWitness) > 0 {
		for k, v := range m.StateWitness {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.FraudulentBeginBlock != nil {
		l = m.FraudulentBeginBlock.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FraudulentDeliverTx != nil {
		l = m.FraudulentDeliverTx.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FraudulentEndBlock != nil {
		l = m.FraudulentEndBlock.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StateWitness) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RootHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.WitnessData) > 0 {
		for _, e := range m.WitnessData {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *WitnessData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovTypes(uint64(m.Operation))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Proofs) > 0 {
		for _, e := range m.Proofs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Echo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestEcho{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_Echo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestFlush{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_Flush{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_Info{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestSetOption{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_SetOption{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitChain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestInitChain{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_InitChain{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestQuery{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_Query{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestBeginBlock{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_BeginBlock{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestCheckTx{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_CheckTx{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliverTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestDeliverTx{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_DeliverTx{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestEndBlock{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_EndBlock{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestCommit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_Commit{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListSnapshots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestListSnapshots{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_ListSnapshots{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestOfferSnapshot{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_OfferSnapshot{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadSnapshotChunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestLoadSnapshotChunk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_LoadSnapshotChunk{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplySnapshotChunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.RequestApplySnapshotChunk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_ApplySnapshotChunk{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAppHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestGetAppHash{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_GetAppHash{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateFraudProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestGenerateFraudProof{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_GenerateFraudProof{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyFraudProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestVerifyFraudProof{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_VerifyFraudProof{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGetAppHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGetAppHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGetAppHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGenerateFraudProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGenerateFraudProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGenerateFraudProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginBlockRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BeginBlockRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliverTxRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeliverTxRequests = append(m.DeliverTxRequests, &types.RequestDeliverTx{})
			if err := m.DeliverTxRequests[len(m.DeliverTxRequests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBlockRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndBlockRequest == nil {
				m.EndBlockRequest = &types.RequestEndBlock{}
			}
			if err := m.EndBlockRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVerifyFraudProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVerifyFraudProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVerifyFraudProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FraudProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FraudProof == nil {
				m.FraudProof = &FraudProof{}
			}
			if err := m.FraudProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedValidAppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedValidAppHash = append(m.ExpectedValidAppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ExpectedValidAppHash == nil {
				m.ExpectedValidAppHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseException{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Exception{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Echo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseEcho{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Echo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseFlush{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Flush{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Info{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseSetOption{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_SetOption{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitChain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseInitChain{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_InitChain{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseQuery{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Query{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseBeginBlock{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_BeginBlock{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseCheckTx{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_CheckTx{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliverTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseDeliverTx{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_DeliverTx{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseEndBlock{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_EndBlock{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseCommit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Commit{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListSnapshots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseListSnapshots{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_ListSnapshots{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseOfferSnapshot{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_OfferSnapshot{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadSnapshotChunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseLoadSnapshotChunk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_LoadSnapshotChunk{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplySnapshotChunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ResponseApplySnapshotChunk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_ApplySnapshotChunk{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAppHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseGetAppHash{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_GetAppHash{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateFraudProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseGenerateFraudProof{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_GenerateFraudProof{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyFraudProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseVerifyFraudProof{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_VerifyFraudProof{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseGetAppHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseGetAppHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseGetAppHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppHash = append(m.AppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.AppHash == nil {
				m.AppHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseGenerateFraudProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseGenerateFraudProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseGenerateFraudProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FraudProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FraudProof == nil {
				m.FraudProof = &FraudProof{}
			}
			if err := m.FraudProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseVerifyFraudProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseVerifyFraudProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseVerifyFraudProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FraudProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FraudProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FraudProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreStateAppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreStateAppHash = append(m.PreStateAppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PreStateAppHash == nil {
				m.PreStateAppHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedValidAppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedValidAppHash = append(m.ExpectedValidAppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ExpectedValidAppHash == nil {
				m.ExpectedValidAppHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateWitness", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StateWitness == nil {
				m.StateWitness = make(map[string]*StateWitness)
			}
			var mapkey string
			var mapvalue *StateWitness
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StateWitness{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StateWitness[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FraudulentBeginBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FraudulentBeginBlock == nil {
				m.FraudulentBeginBlock = &types.RequestBeginBlock{}
			}
			if err := m.FraudulentBeginBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FraudulentDeliverTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FraudulentDeliverTx == nil {
				m.FraudulentDeliverTx = &types.RequestDeliverTx{}
			}
			if err := m.FraudulentDeliverTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FraudulentEndBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FraudulentEndBlock == nil {
				m.FraudulentEndBlock = &types.RequestEndBlock{}
			}
			if err := m.FraudulentEndBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateWitness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateWitness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateWitness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &crypto.ProofOp{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append(m.RootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RootHash == nil {
				m.RootHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WitnessData = append(m.WitnessData, &WitnessData{})
			if err := m.WitnessData[len(m.WitnessData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WitnessData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WitnessData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WitnessData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proofs = append(m.Proofs, &crypto.ProofOp{})
			if err := m.Proofs[len(m.Proofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
